#!/bin/sh
# devtmpfs does not get automounted for initramfs
echo "RaGaVa >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Ready Start" > /dev/console
/bin/mount -t devtmpfs devtmpfs /dev

# use the /dev/console device node from devtmpfs if possible to not
# confuse glibc's ttyname_r().
# This may fail (E.G. booted with console=), and errors from exec will
# terminate the shell, so use a subshell for the test
if (exec 0</dev/console) 2>/dev/null; then
    exec 0</dev/console
    exec 1>/dev/console
    exec 2>/dev/console
fi

# exec /sbin/init "$@"

status_file=/dev/console

echo "Start init.sh" > $status_file

export PATH="/usr/bin:/usr/local/bin:/bin:/root/bin:/sbin:/usr/sbin:/usr/local/sbin"
export HOME="/root"
# mkdir -p /proc
# mount -t proc proc /proc
# mount -n -t tmpfs none /dev
# mkdir -p /sys
# mount -t sysfs sysfs /sys
# mknod -m 622 /dev/console c 5 1
# mknod -m 666 /dev/null c 1 3
# mknod -m 666 /dev/zero c 1 5
# mknod -m 666 /dev/ptmx c 5 2
# mknod -m 666 /dev/tty c 5 0 # <--
# mknod -m 444 /dev/random c 1 8
# mknod -m 444 /dev/urandom c 1 9
# chown root:tty /dev/{console,ptmx,tty}

# #setup loop device
# mknod -m 660 /dev/loop-control c 10 237
# mknod -m 600 /dev/loop0 b 7 0

# Define the quit function.
# In any case of failure, this quit fuction will be called and the init process will run the infinite sh job.
quit_job()
{
    echo -e "$*"
    /bin/sh
}
# TODO: POSIX sh doesn't support export a function.
# export -f quit_job

#add sev dev
# mknod /dev/sev c 10 127

export os_drive_letter=sda
# set up the first partition for config file and log.
# mknod /dev/$os_drive_letter b 8 0
echo "RaGaVa >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Before FDISK " > /dev/console
partitions_num=`fdisk -l /dev/$os_drive_letter | sed '1,/Number  Start (sector)    End (sector)  Size Name/d' | wc -l`

#if [ $partitions_num -lt 3 ]
#    then quit_job "The disk /dev/$os_drive_letter is not valid, or it does not have at least three partitions." >> $status_file
#fi
# Create the boot partition device. Please note that according to the layout of Azure Linux Image layout, the partition number is hardcoded to 2.
# mknod /dev/${os_drive_letter}2 b 8 2

# Define the boot partition mount point here ealier, since the boot partition should be mounted to get the image_config.json.
export config_destination=/mnt/${os_drive_letter}2
export readonly_detination=/mnt/sda3
export writable_destination=/mnt/sda4
export overlay_destination=/mnt/sda
mkdir $config_destination -p
mount /dev/sda2 $config_destination
#if [ $? -ne 0 ]; then
#    quit_job "Mount partition 1 failed." >> $status_file
#else
#    mv $status_file $config_destination/
#    status_file=$config_destination/status
#fi

echo "RaGaVa >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> : After Mount /dev/sd2" > /dev/console

# set up network
# /etc/init.d/networkctl.sh >> $status_file

# echo "sshd started" >> $status_file
# mkdir -p /dev/pts
# mount devpts /dev/pts -t devpts
# /usr/sbin/sshd

#NTP
# chronyd && chronyc -a makestep

# echo "set up hostname" >> $status_file
# hostname `cat /etc/hostname`

# /etc/init.d/report_azure_ready.sh >> $status_file 2>&1

#chroot to Ubuntu OS.
#!!! exec to run the script with PID 1
# exec /etc/init.d/os.sh >> $status_file 2>&1

echo "RaGaVa >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> : exec /sbin/init" > /dev/console

exec /sbin/init "$@"

#place an infinity job here in case chroot job terminates accidently.
quit_job "Unexpected execution route."

